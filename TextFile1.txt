Выражения это синтаксическая конструкция состоящая из операндов и операторов

ООП на языке С++ -это подход при котором программа строится из объектов
Объекты могу взаимодействовать между собой.Ключевы понятием в ООП является объект.
Объект это некая сущесноть,которая существет в пространстве и времени
Объекты могу существовать в объективной, субъективной или же виртуальной реальности 
ООП позволяет спроецировать объекты объективной субъективной реальности в виртуальную реальность
Есть свои характеристики ,состояния, поведения
Объекты приято классифицировать
Множество объектов с одинаковых наборов характеристик,состояний и поведений называется классы
Например:класс телефон,человек,компьютер и тд
С точки зрения ООП, класс это синтактическая конструкция, позволяющая описывать объекты
Кроме классов, объекты можно описывать при помощи структуры
Классы и структуры состоят из полей или же членов (Members).
Поля классов или структур бывают двух типов:
1)Переменны члены класса-описываю характеристики и состояния объектов.
2)Методы определяют поведения объектов и взаимодействия их с другими объектами
  Метод -это функция внутри классы
  Метод может вызвать только для каково то объекта
  Классы или структуры часто отображают виде UML диаграмм
  Функции внутри класса -определяет поведения объектов и взаимодействие из сдругими объектами

  Переменные члены класса- описывают характеристики и состояния объекта
  

  /Обращение к полям объекта 
//Для обращение к полям объекта 
//Можно использовать оператор 
//.    -Это оператор прямого доступа(используется для доступа к полям объекта по имени объекта)
//->   -Оператор косвенного доступа (Arrow operator) используется для доступа к полям объекта по адресу объекта

//Концепции ООП
//
//1.Инкпапсуляция - Это сокрытие определенной части класса от внешнего мира
//Инкапсуляция реализуется модификаторами доступа  get; set методами
//В языке С++ существут 3 модификатора доступа :
//private:-закрытие поля, доступны внутри класса, переменные члены класса должны быть приватными, это защищает их от случайной перезаписи.
//public: -это открытые поля, доступны из любого места программы. В паблик секции обычно размещают методы.
//protected: Защищенные поля, доступны внутри нашего класса и его дочерних классов(этот модификатора доступа, используются только при наследовании)
//    Единственным отличием класса и структуры является то, что в структуре все поля по умолчанию открыты а в классе все поля по умолчанию закрыты
//    get; set - обеспечивают доступ из вне к закрытым переменам в классе
//    get(взять\получит) - позволяют получить(взять) Знапчение переменной(открывают доступ на чтение  к переменным членам  класса)
//    set(назначить, задать.установить) - позволяют задать значение переменой в классе )
//    или же открывают в доступ к переменным членам класса на запись.Кроме того set  методы  обеспечивают фильтрацию данных
//    get методы обязательно должны быть константными
//    Константы называются метод, которые не изменяет объект для которого вызывается
//    Для константного объекта могут быть вызваны только константные методы 
//    this -это указатель на объект для которого вызывается метод
// 
//    2.Наследование
//    3.Полиморфизм

Особые методы в классе
В любом классе, обязательно должны быть такие методы как КОНСТРУКТОР,ДЕСТРУКТОР и оператор присваивания (Constructor,~Destructor,Assing operator)
Конструктор - это метод, который создает объект а именно выделяет память под объект и инициализирует его поля при создании объекта
Деструктор  - это метод,который уничтожает объект,по истечению времени жизни.Время жизни объекта истекает тогда мы выходи за пределы области видимости ,который объявлен этот объект 
Например: при завершении функции в которой объявлен объект или если счетчик цикла for считать объектом ,то по завершению все операцию for для счетчика буде вызван Декструктор 
Конструкторы и деструкторы всегда вызываются также как и класс. Но перед деструктором всегда ставиться символ ~ Тильда
Конструкторы и деструктор никого не возвращают никаких значений и при этом перед ними даже не пишется void 
Конструктор как и любая функция может принимать параметр по этому как и любую другую функцию ее можно перегрузить .Это означает  то что в классе может быить сколько угодно конструкторов
Деструктор же никого ни приминает никаких параметров и перегрузить его нельзя, следовательно в любом классе может быть только ОДИН деструктор.
Объекты могут создаваться по разному. Все объекты удаляются одинаково независимо от того как они были созданы

Конструкторы бывают с параметрами,бнз параметров,по умолчанию,конструкто опирования и конструктор переноса
Конструктор по умолчанию-это конструктор,который может быть вызван без параметра.
Это может быть конструкт не принимающих никаких параметров или же конструкто каждый параметр имеет значение по умолчанию.
Конструктор по умолчани Выделяет память под объект и иницилизурет все его поля знапчениями по умолчанию.
Конструктор по умолчанию всякий раз неявно вызывается,когда мы просто создаеим объек и не знаем каким он будет,например Point A //Default constructor
Конструкр по умолчанию может быть неявным т.е если в классе нет ниодного конструктора то компилятор сам добавит конструк по умолчанию потому что без констркутор невозможно содать объект
такой неявный конструктор по умолчанию проосто выделяет памаять под объект и иницилизирут его поля значениями по умолчанию 

Если мы хотим определять какие будут объекты при его создания то нам нужен конструктор с параметром
Особое место параметризованом занимает конструктор занимает с одним параметром,короый позволяе создовать объект Point C=4;
Конструктор с параметром по умолчанию может быть универсальным и вызвапться во всех случиях создание объекта,но иногода лучше перегрузчить конструтор чем использовать универсальный конструктор

23.01
Конструкор копирование - это конструкор,корорый копируют объекты.
А имеено создаваемые объекты делает точные компиии какго-то существующего объекта.
Конструктор копирования всегда принимет костантную ссылку на объект нашего класса
Он всякий раз неяно вызвывется ,когда нужно скопировать объект.Например Point D=C(Вызывается конструкто копирования)
Дакже как и конструктор по умолчанию Конструктор копирования может быть неявным т.е еслим мы его не написали то компилятор сам его добавит 
Коструктор копирования особено важен при импользовании в классе динамической памяти.Он долден выполнять глубокое копирование (deep copy),побитовое копирование,побайтовое копирование,по элементное копирование
Неявный конструктор копирование не может этого сделать и он вывполняет поверностное копирование(Shallow copy) т.е копирование адресса памяти,всемто содержимого памяти 

Если возникает необходимость скопировать существующий объект  а именно существующий объект сделать точной копией другого существующего объекта.
Для этой цели мы несможем вызвать Мы не сможем вызвать конструктор копирования .
Потому что любой конструктор может быть вызван только для создания объекта.
Для того,чтобы скопировать существующий объект вызывается оператор присваивания (или же CopyAssighment)
Оператор присваивание делает тоже самое что и конструктор копирования но для существующего объекта()
Таже как и конструктор копирования опиратор присваивания приманет костантную ссылку на объект
Он вывполняет теже самые действия что и конструктор копирования но для существующего объекта
Также как и конструктор копирования,оператор присваивание критически важен,если в классе используется динамическая память и он также может быть неявным 
также как и конструктор копирования оператор присваивания должен выполять DeepCopy

25.01
Мы много говорили о том как можно передать параметру функци(по значениию,по укозателя и по ссылке) но мы никогода не говори о том как функция может возвращать значение.
Значение из функции также можно возращаться по значени,по указателю или же по ссылке
И при возрате значения про значению,возвращаемое значение копируется на место вызова
А при взоврате значение по укозателю либо по ссылке на место вызова копируется адресс возвращаемого значения 
Если возращаемое значение является объектом.Для того его скопировать на место вызова  вызвается коструктор копирования 
Для того чтобы скопировать адресс объекта конструктор копирования не нужен.

При возрате объекта по знасччению создается еще один объект,что приводит дополнительно затратам ресурса .Возращая объкт по адресу можно сэкономить ресурсы.Но здесь нужно быть очень осторожным
По скольку,если  вернем ссылку или указатель на локальный объект,то он удалиться по завршению функции и на месте вызова мы увидим мусор 
Область видимости может состоять из ниеколько выражений но каждое выражение является областью видимости


----------------------------------------------------------------------------------------------------------
Перегрузка операторов 

Перегрузка операторов для более удобной работы с объектами
Чтобы над объектами можно было бы выврлнчть такие же действия как на обычными переменными

Правила перегрузки оператора
1. Перегрузчить можно только существующие операторы,невозможно создавать новые операторы
   Например:
   + - перегружается
   ++ - перегружается
   * - перегружается
   ** -не перегружается

2. Не все существующие операторы можно перегрузить
   НЕ перегружаются:
   
   ?: - не перегружается (Conditional ternart)
   :: - Stop operator (Оператор разрешения видимости)
   .  - Point operator (Оператор прямого доступа)
   .* - Pointer to member selection
   #- Prerpocessor (передпроцессор)
   ## Prerpocessor concatenotal 

3.Переопределить поведение операторов на встроенныими типами невозможно !
Например: новеозможно завставить оператор + выполнять какие нибудь действия над типом данных int  кроме сложения 

4.Перегруженные операторы сохраняют приоритет. 


Пергруженные операторы - это самые обычные функции имя которых состоит из ключевого слово operator и знака существующего оператора 
Эти функции можно описать как в классе так и за классом 
если оператор перегружн в классе,то он является МЕТОДОМ  а значит может быть вызван только для какого-то объекта 
Если оператор перегружен за классом то он является самой обычной фунцией  а значит может ыбть вызван сам по себе 
Если унарный оператор перегружен внутри класса то он никога не принимает никаких параметров а единствееный его операндом является объек для которого он вызывается к этому объекту можно обращаться через this
Если унарный оператор перегржун за классом то он в обязательном порядке принимает один и только один параметр - свой операнд
Если бианарный орперанд перегружен внутри класса то он в обязательном порядке принимает один и только один параметр - свой операнд справа а операндам слева является объект для которого он вызывается
Если бинарный оператор пергружен за классом,то он в обязательном порядке принимает два параметра-свои операрнды 

При пергрузке оператора всегда следует учитывать что некорые операторы изменяют свои операнды а некоторые нет 
Те операторы которые измеяют свои операнды удобнее пергружать внутри класса,чтобы иметь прямой доступ к перемнным членам класса.
ТЕ Операторы которые неизменяют свои операнды удобнее пегружать за классами

26.01.

Перегрзука оператора сравнеия 
Операторы сравнения всегда возращают значения типа bool
Их лучше перегружать за классом потому что они не изменяют свои операнда

02.02.23

Преоброзование типов 
Существует явное и не явные преоброзование типов 
Явное преоброзование выполняет програмист а не явные копилятор
Для того чтобы преоброзовать значение в другно тип данных,необходимо желаемый тип данных написать в круглых скобка перед значением или хначение в круглых скобках после желаемого типа данных



 //(type) value; // C-LIke notation (C- подобная форма записи)
 //type(value); // Functional notation (Функциональная форма записи)

 Точто невяные проброзование типов выполняет компилятор а именно операторы.
 Все операторы С++ пытаются привести все значения в выражении к наибольшие типов данных 
 Для того чтобы избежать потери данных и вернуть максимальный точный результат  кроме присваиваний.
 Операторы присваивания всегда значения справа приводит к типу слева,,если тыпы преобразуются и не вожно произойт потеря данных или нет 
 Так явные и так неявные приоброзования бываеют от мечего к большему так и отбольшего к меньшему.Причем к последнему может привести к потери данных при этом компилятор обычно выдает предуприждения.
 С4244 (возможная потеря данных)

 int a=2;         //No vonversions
 double b=3;     //Conversion from less to more    
 int c=b;       //Conversion from more to less with no dfata loss
 int D=4,5  //Conversion from more to less with data loss

 Преоброзование типов в ООП
 Существуют два направления преоброзование типов 

 1.Преоброзование других типов в наш 
 2 Преоброзование из нашего типа в другие типы 

 В объекты нашего класса в классе должны быть конструкт с одним параметром  и оператор присваивания,причем втрой без первого не работет
 
 Fraction A=5; Conversion from other to class performed by Single-argument constuctor

 Fraction B
 B=8  Conversion from other to class  preformed by Assigne


 К конструтор с одним параметром принимо ключевое слова exppicit- явный

 Ключевое слова explici запрещает неявный преоброзование типов и остовляет возможность лишь явно преоброзовывать типы 

 Для того чтобы объекты нашего класса преобразовывать в другие типы данных в классе должны быть соответствующие операторы преоброзования 
 Операторы преоброзования (type -cast operators) это самые обычные методы имя которых состоит из ключевого слово оператор и спецификатора сущестувущего типа 

 operator type() const
 {
 
 conversion algorithm;
 return;
 
 }

 Операторы преоборозвания можно перегрузить только внутри класса 
 операторы преоброзование обязательном порядке возвращают значение хотя перед ними никогда не пишется тип возращаемого значения по скольку он является частью имени оператора  


К операторам преоброзования типов также применимо ключевое слова ,которая такжн запрещает неявные преборозования 
 

 08.02
 Использование динамической памяти в классе
 Если в классе есть хотябыф один указатель то скорее всего он указывает на область динамической памяти.Если это так ,то в конструкторах будет использоваться оператор new
 Если оператор New используется в конструторах то в классе обязятелно должент деструктор с оператором Delete

 Кроме того в таком классе обязательно должны быть коструктор копирования и оператор присванивания
 Эти методы выполняют побитовое копирование или же DeepCopy(побитовое копирование) а именно выделяют память с помощью оператора New и копирует все содержимое в создаваемые объекты
 Неявные же коноструктор копирование и оператор присваивание выполняют Shallowcopy(поверхностное копирование),что приводит к тому что появляется ждва и более объекта владеющей одной и той же областью  динамической памяти
 что в свою очередь приводит к ошибка на этапае компилирование

 09.02.23

 Методы Переноса
 К ним относяться коноструктор переноса(MoveConstuctor  ) и оператор присваивание переноса(MoveAssignment)
 Методы перноса предназначены для того чтобы создавать или существующий объект проинцилиазировать значение временного безымянного объекта
 Временный безымянный объект всякий раз неявносоздается когда функция возращает значение по значению тогда
 возвращаемое значение копируется на место вызова и на месте вызова создается временный безымянный объект 
 Времееный безымянный объекты создаеются в пределах одного выражения 
 Если возращаемая значение функции является объектом то для того чтобы его скопировать на место вызова вызывается конструкто копирования 
 а если этот объект использует динамическую память то конструктор копирования еще выполняет побитовое копирование(DeepCopy)
 что приводит затрата ресурсов памяти и процессорного времени 
 Все эти ресурсы затрачиваются на копировании объекта,который сразу же будет удален из памяти и ресурсы занимаемые из даннного объекта будут освобожденны
 Для того чтобы не копировать объект который сечайже будет удален можно просто взять в память принадлежащему этому объекту и перенсти ее на место вызова
 Эту функцию выполняют Move методы.В отличии от копии методов,который выполняют DeepCopy Move методы выполняют Shallow copy т.е из-за одного объекта в другой
 копирут указатель на сущенствующею павмять без выделения новой памяти .А скопировать 4х или восьмибайтовый указтель всегда будет быстрее чем скопировать массив с данными
 Для локального объекта перенесенного на место вызова в любом случае вызывается деструктор,которую очисть память перенесенную на место вызова для того,чтобы это не произошло 
 Move медоты кроме Shellow copy обязательно должны  обнулять другой объект (other),в противном случае перенесенная память будет очищена 
 Move semantic вперывый появилась в стандарте с++11 С++03 были лишл copy методы 
 Move медоты могут в значитеьном степени могут повысить призовдительность при имспользовании динамической памяти 
 Move медоты приниимают никостанту и не ссылку a R-value refernce