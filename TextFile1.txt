Выражения это синтаксическая конструкция состоящая из операндов и операторов

ООП на языке С++ -это подход при котором программа строится из объектов
Объекты могу взаимодействовать между собой.Ключевы понятием в ООП является объект.
Объект это некая сущесноть,которая существет в пространстве и времени
Объекты могу существовать в объективной, субъективной или же виртуальной реальности 
ООП позволяет спроецировать объекты объективной субъективной реальности в виртуальную реальность
Есть свои характеристики ,состояния, поведения
Объекты приято классифицировать
Множество объектов с одинаковых наборов характеристик,состояний и поведений называется классы
Например:класс телефон,человек,компьютер и тд
С точки зрения ООП, класс это синтактическая конструкция, позволяющая описывать объекты
Кроме классов, объекты можно описывать при помощи структуры
Классы и структуры состоят из полей или же членов (Members).
Поля классов или структур бывают двух типов:
1)Переменны члены класса-описываю характеристики и состояния объектов.
2)Методы определяют поведения объектов и взаимодействия их с другими объектами
  Метод -это функция внутри классы
  Метод может вызвать только для каково то объекта
  Классы или структуры часто отображают виде UML диаграмм
  Функции внутри класса -определяет поведения объектов и взаимодействие из сдругими объектами

  Переменные члены класса- описывают характеристики и состояния объекта
  

  /Обращение к полям объекта 
//Для обращение к полям объекта 
//Можно использовать оператор 
//.    -Это оператор прямого доступа(используется для доступа к полям объекта по имени объекта)
//->   -Оператор косвенного доступа (Arrow operator) используется для доступа к полям объекта по адресу объекта

//Концепции ООП
//
//1.Инкпапсуляция - Это сокрытие определенной части класса от внешнего мира
//Инкапсуляция реализуется модификаторами доступа  get; set методами
//В языке С++ существут 3 модификатора доступа :
//private:-закрытие поля, доступны внутри класса, переменные члены класса должны быть приватными, это защищает их от случайной перезаписи.
//public: -это открытые поля, доступны из любого места программы. В паблик секции обычно размещают методы.
//protected: Защищенные поля, доступны внутри нашего класса и его дочерних классов(этот модификатора доступа, используются только при наследовании)
//    Единственным отличием класса и структуры является то, что в структуре все поля по умолчанию открыты а в классе все поля по умолчанию закрыты
//    get; set - обеспечивают доступ из вне к закрытым переменам в классе
//    get(взять\получит) - позволяют получить(взять) Знапчение переменной(открывают доступ на чтение  к переменным членам  класса)
//    set(назначить, задать.установить) - позволяют задать значение переменой в классе )
//    или же открывают в доступ к переменным членам класса на запись.Кроме того set  методы  обеспечивают фильтрацию данных
//    get методы обязательно должны быть константными
//    Константы называются метод, которые не изменяет объект для которого вызывается
//    Для константного объекта могут быть вызваны только константные методы 
//    this -это указатель на объект для которого вызывается метод
// 
//    2.Наследование
//    3.Полиморфизм

Особые методы в классе
В любом классе, обязательно должны быть такие методы как КОНСТРУКТОР,ДЕСТРУКТОР и оператор присваивания (Constructor,~Destructor,Assing operator)
Конструктор - это метод, который создает объект а именно выделяет память под объект и инициализирует его поля при создании объекта
Деструктор  - это метод,который уничтожает объект,по истечению времени жизни.Время жизни объекта истекает тогда мы выходи за пределы области видимости ,который объявлен этот объект 
Например: при завершении функции в которой объявлен объект или если счетчик цикла for считать объектом ,то по завершению все операцию for для счетчика буде вызван Декструктор 
Конструкторы и деструкторы всегда вызываются также как и класс. Но перед деструктором всегда ставиться символ ~ Тильда
Конструкторы и деструктор никого не возвращают никаких значений и при этом перед ними даже не пишется void 
Конструктор как и любая функция может принимать параметр по этому как и любую другую функцию ее можно перегрузить .Это означает  то что в классе может быить сколько угодно конструкторов
Деструктор же никого ни приминает никаких параметров и перегрузить его нельзя, следовательно в любом классе может быть только ОДИН деструктор.
Объекты могут создаваться по разному. Все объекты удаляются одинаково независимо от того как они были созданы

Конструкторы бывают с параметрами,бнз параметров,по умолчанию,конструкто опирования и конструктор переноса
Конструктор по умолчанию-это конструктор,который может быть вызван без параметра.
Это может быть конструкт не принимающих никаких параметров или же конструкто каждый параметр имеет значение по умолчанию.
Конструктор по умолчани Выделяет память под объект и иницилизурет все его поля знапчениями по умолчанию.
Конструктор по умолчанию всякий раз неявно вызывается,когда мы просто создаеим объек и не знаем каким он будет,например Point A //Default constructor
Конструкр по умолчанию может быть неявным т.е если в классе нет ниодного конструктора то компилятор сам добавит конструк по умолчанию потому что без констркутор невозможно содать объект
такой неявный конструктор по умолчанию проосто выделяет памаять под объект и иницилизирут его поля значениями по умолчанию 

Если мы хотим определять какие будут объекты при его создания то нам нужен конструктор с параметром
Особое место параметризованом занимает конструктор занимает с одним параметром,короый позволяе создовать объект Point C=4;
Конструктор с параметром по умолчанию может быть универсальным и вызвапться во всех случиях создание объекта,но иногода лучше перегрузчить конструтор чем использовать универсальный конструктор

23.01
Конструкор копирование - это конструкор,корорый копируют объекты.
А имеено создаваемые объекты делает точные компиии какго-то существующего объекта.
Конструктор копирования всегда принимет костантную ссылку на объект нашего класса
Он всякий раз неяно вызвывется ,когда нужно скопировать объект.Например Point D=C(Вызывается конструкто копирования)
Дакже как и конструктор по умолчанию Конструктор копирования может быть неявным т.е еслим мы его не написали то компилятор сам его добавит 
Коструктор копирования особено важен при импользовании в классе динамической памяти.Он долден выполнять глубокое копирование (deep copy),побитовое копирование,побайтовое копирование,по элементное копирование
Неявный конструктор копирование не может этого сделать и он вывполняет поверностное копирование(Shallow copy) т.е копирование адресса памяти,всемто содержимого памяти 

Если возникает необходимость скопировать существующий объект  а именно существующий объект сделать точной копией другого существующего объекта.
Для этой цели мы несможем вызвать Мы не сможем вызвать конструктор копирования .
Потому что любой конструктор может быть вызван только для создания объекта.
Для того,чтобы скопировать существующий объект вызывается оператор присваивания (или же CopyAssighment)
Оператор присваивание делает тоже самое что и конструктор копирования но для существующего объекта()
Таже как и конструктор копирования опиратор присваивания приманет костантную ссылку на объект
Он вывполняет теже самые действия что и конструктор копирования но для существующего объекта
Также как и конструктор копирования,оператор присваивание критически важен,если в классе используется динамическая память и он также может быть неявным 
также как и конструктор копирования оператор присваивания должен выполять DeepCopy

25.01
Мы много говорили о том как можно передать параметру функци(по значениию,по укозателя и по ссылке) но мы никогода не говори о том как функция может возвращать значение.
Значение из функции также можно возращаться по значени,по указателю или же по ссылке
И при возрате значения про значению,возвращаемое значение копируется на место вызова
А при взоврате значение по укозателю либо по ссылке на место вызова копируется адресс возвращаемого значения 
Если возращаемое значение является объектом.Для того его скопировать на место вызова  вызвается коструктор копирования 
Для того чтобы скопировать адресс объекта конструктор копирования не нужен.

При возрате объекта по знасччению создается еще один объект,что приводит дополнительно затратам ресурса .Возращая объкт по адресу можно сэкономить ресурсы.Но здесь нужно быть очень осторожным
По скольку,если  вернем ссылку или указатель на локальный объект,то он удалиться по завршению функции и на месте вызова мы увидим мусор 
Область видимости может состоять из ниеколько выражений но каждое выражение является областью видимости


----------------------------------------------------------------------------------------------------------
Перегрузка операторов 

Перегрузка операторов для более удобной работы с объектами
Чтобы над объектами можно было бы выврлнчть такие же действия как на обычными переменными

Правила перегрузки оператора
1. Перегрузчить можно только существующие операторы,невозможно создавать новые операторы
   Например:
   + - перегружается
   ++ - перегружается
   * - перегружается
   ** -не перегружается

2. Не все существующие операторы можно перегрузить
   НЕ перегружаются:
   
   ?: - не перегружается (Conditional ternart)
   :: - Stop operator (Оператор разрешения видимости)
   .  - Point operator (Оператор прямого доступа)
   .* - Pointer to member selection
   #- Prerpocessor (передпроцессор)
   ## Prerpocessor concatenotal 

3.Переопределить поведение операторов на встроенныими типами невозможно !
Например: новеозможно завставить оператор + выполнять какие нибудь действия над типом данных int  кроме сложения 

4.Перегруженные операторы сохраняют приоритет. 


Пергруженные операторы - это самые обычные функции имя которых состоит из ключевого слово operator и знака существующего оператора 
Эти функции можно описать как в классе так и за классом 
если оператор перегружн в классе,то он является МЕТОДОМ  а значит может быть вызван только для какого-то объекта 
Если оператор перегружен за классом то он является самой обычной фунцией  а значит может ыбть вызван сам по себе 
Если унарный оператор перегружен внутри класса то он никога не принимает никаких параметров а единствееный его операндом является объек для которого он вызывается к этому объекту можно обращаться через this
Если унарный оператор перегржун за классом то он в обязательном порядке принимает один и только один параметр - свой операнд
Если бианарный орперанд перегружен внутри класса то он в обязательном порядке принимает один и только один параметр - свой операнд справа а операндам слева является объект для которого он вызывается
Если бинарный оператор пергружен за классом,то он в обязательном порядке принимает два параметра-свои операрнды 

При пергрузке оператора всегда следует учитывать что некорые операторы изменяют свои операнды а некоторые нет 
Те операторы которые измеяют свои операнды удобнее пергружать внутри класса,чтобы иметь прямой доступ к перемнным членам класса.
ТЕ Операторы которые неизменяют свои операнды удобнее пегружать за классами









